<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Sphere Rendering</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js" defer></script>
    <script src="util.js" defer></script>
</head>

<body>
    <!-- <script type="x-shader/x-fragment">
        uniform vec3 cameraPos;
        uniform vec3 lightPos;

        struct Ray {
            vec3 origin;
            vec3 direction;
        }

        struct Sphere {
            vec3 center;
            float radius;
        }

        struct PointLight {
            vedposition
        }

        vec3 trace_ray() {}

        float intersectSphere(in Ray ray, in Sphere) {
            vec3 co = ray.origin - sphere.center;
            float discriminant = dot(co, ray.direction) * dot(co, ray.direction) - (dot(co, co) - sphere.radius * sphere.radius);

            if (discriminant >= 0.0)
                return -dot(ray.direction, co) - sqrt(discriminant);
            else
                return -1;
        }
    </script> -->
    <canvas id="canvas" width="600" height="400"></canvas>
    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform vec4 uColor;

        void main() {
            gl_FragColor = uColor;
        }
  </script>

  
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        uniform mat4 uModelMatrix;
        uniform mat4 uViewMatrix;
        uniform mat4 uProjectionMatrix;
        void main() {
            gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
        }
  </script>

    <script>
        let gl = null;
        let glCanvas = null;

        // Vertex information
        let vertexArray, vertexBuffer, indexArray, indexBuffer;

        // Rendering data
        let uModelMatrix, uViewMatrix, uProjectionMatrix, uColor, shaderProgram;

        const spherePositions = [
            [0, 0, 0],
            [10, 0, 0],
            [-10, 0, 0]
        ];

        const sphereColors = [
            [1.0, 0.0, 0.0, 1.0], // Red
            [0.0, 1.0, 0.0, 1.0], // Green
            [0.0, 0.0, 1.0, 1.0] // Blue
        ];
        const compileShader = (id, type) => {
            const code = document.getElementById(id).firstChild.nodeValue;
            const shader = gl.createShader(type);

            gl.shaderSource(shader, code);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.log(
                    `Error compiling ${
                  type === gl.VERTEX_SHADER ? "vertex" : "fragment"
                } shader:`,
                );
                console.log(gl.getShaderInfoLog(shader));
            }
            return shader;
        };
        const buildShaderProgram = (shaderInfo) => {
            const program = gl.createProgram();

            shaderInfo.forEach((desc) => {
                const shader = compileShader(desc.id, desc.type);

                if (shader) {
                    gl.attachShader(program, shader);
                }
            });

            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.log("Error linking shader program:");
                console.log(gl.getProgramInfoLog(program));
            }

            return program;
        };
        const animateScene = (currentTime) => {
            gl.enable(gl.DEPTH_TEST);
            gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            gl.clearColor(0.8, 0.9, 1.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            let viewMatrix = mat4.create();
            let projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, 45 * Math.PI / 180, glCanvas.width / glCanvas.height, 0.1, 100.0);
            mat4.lookAt(viewMatrix, [0, 0, -20], [0, 0, 0], [0, 1, 0]);

            gl.uniformMatrix4fv(uViewMatrix, false, viewMatrix);
            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);

            spherePositions.forEach((position, index) => {
                let modelMatrix = mat4.create();
                mat4.translate(modelMatrix, modelMatrix, position);
                // mat4.scale(modelMatrix, modelMatrix, [0.3, 0.3, 0.3]);
                gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
                gl.uniform4fv(uColor, sphereColors[index]);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.vertexAttribPointer(aVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aVertexPosition);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.drawElements(gl.TRIANGLES, indexArray.length, gl.UNSIGNED_SHORT, 0);
            });

            requestAnimationFrame(animateScene);
        };

        const startup = () => {
            glCanvas = document.getElementById("canvas");
            gl = glCanvas.getContext("webgl");

            const shaderSet = [{
                    type: gl.VERTEX_SHADER,
                    id: "vertex-shader"
                },
                {
                    type: gl.FRAGMENT_SHADER,
                    id: "fragment-shader"
                }
            ];

            shaderProgram = buildShaderProgram(shaderSet);
            gl.useProgram(shaderProgram);

            uColor = gl.getUniformLocation(shaderProgram, "uColor");
            uModelMatrix = gl.getUniformLocation(shaderProgram, "uModelMatrix");
            uViewMatrix = gl.getUniformLocation(shaderProgram, "uViewMatrix");
            uProjectionMatrix = gl.getUniformLocation(shaderProgram, "uProjectionMatrix");

            vertexArray = generateSphereVertices(2, 20, 20);
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexArray), gl.STATIC_DRAW);

            indexArray = generateIndicesForSphere(20, 20);
            indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), gl.STATIC_DRAW);

            aVertexPosition = gl.getAttribLocation(shaderProgram, "aVertexPosition");

            animateScene();
        };

        window.addEventListener("load", startup, false);
    </script>
</body>

</html>